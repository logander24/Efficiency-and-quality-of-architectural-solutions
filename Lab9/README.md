Рефакторинг: уникнення ланцюжка викликів

    Огляд
        У оригінальному коді є ланцюжок викликів `bank.get_customer().get_account().get_balance()`, який отримує баланс рахунку. Такі ланцюжки можуть призвести до високого зв’язку між класами та ускладнити підтримку та розширення коду. Щоб вирішити цю проблему, ми рефакторюємо код відповідно до принципу «закону Деметри», який сприяє низькому зв’язку та кращій інкапсуляції.

    Внесено зміни
        1. Додано метод `get_customer_balance` в клас `Bank`:
            - Цей метод безпосередньо повертає баланс шляхом делегування внутрішніх викликів у класі `Bank`.
            - Це дозволяє уникнути впливу внутрішніх елементів класів `Customer` і `Account` на код клієнта.

    Переваги
        - Зменшений зв’язок: код клієнта більше не потребує знання внутрішньої структури `Bank`, `Customer` і `Account`.
        - Покращена інкапсуляція: кожен клас виконує свої власні обов’язки, не розкриваючи непотрібних деталей іншим класам.
        - Просте обслуговування: майбутні зміни внутрішньої структури цих класів не вплинуть на код клієнта, доки інтерфейс методу `get_customer_balance` залишається незмінним.

Висновок
    Завдяки рефакторингу для інкапсуляції ланцюжка методів ми покращуємо конструкцію та зручність обслуговування коду, дотримуючись принципів об’єктно-орієнтованого проектування.