Рефакторинг: звернення до ревнивих функцій

    Огляд
        Оригінальний код мав клас `Order` з методами, які заздрили обов’язкам класу `Customer`, зокрема щодо обробки адреси клієнта та визначення вартості доставки на основі цієї адреси. Перероблений код переміщує розрахунок вартості доставки до класу `Customer`, який є більш відповідним, оскільки вартість доставки визначається адресою клієнта.

    Внесено зміни
        1. Переміщено `calculate_shipping_cost` до `Customer` Class:
            - Розрахунок вартості доставки залежить від адреси клієнта, тому він логічно належить до класу `Клієнт`.
            - Це покращує згуртованість і гарантує, що кожен клас справляється зі своїми обов'язками.

        2. Оновлено `print_order_details` в `Order` Class:
            - Цей метод тепер лише друкує деталі замовлення та отримує вартість доставки за допомогою виклику методу класу `Customer`.
            - Ця зміна робить метод більш цілеспрямованим і згуртованим.

    Переваги
        - Покращена зв’язність коду: тепер кожен клас обробляє власні дані та пов’язану з ними поведінку.
        - Краща інкапсуляція: клас `Customer` тепер інкапсулює всі деталі про клієнта, включаючи операції на основі адреси.
        - Зменшений запах коду: рефакторинг усуває запах ревнивих функцій, гарантуючи, що методи знаходяться в класах, яким вони логічно належать.

Висновок
    Цей рефакторинг покращує дизайн коду, дотримуючись об’єктно-орієнтованих принципів, зокрема когезії та інкапсуляції. Кожен клас тепер чітко визначає свої обов’язки, що веде до більш зручного та зрозумілого коду.